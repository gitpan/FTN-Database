#!/usr/bin/perl
# nl2ftndb  - Initial load of a particular Fidonet/FTN St. Louis Format Nodelist
# into an SQL Database for Fidonet/FTN processing. The SQL Database engine is 
# one for which a DBD module exists, defaulting to SQLite.
#
# Copyright (c) 2010 Robert James Clay.  All Rights Reserved.
# This is free software;  you can redistribute it and/or
# modify it under the same terms as Perl itself.

use warnings;
use strict;
use Getopt::Std;
use vars qw/ $opt_n $opt_T $opt_D $opt_u $opt_p $opt_f $opt_e $opt_l $opt_d $opt_h $opt_t $opt_v $opt_x $opt_z /;

use FTN::Database qw(&open_ftndb &close_ftndb);
use FTN::Database::Nodelist qw(&create_ftnnode_index &drop_ftnnode_index);
use FTN::Log qw(&logging);

our $VERSION = 0.09;

getopts('n:T:D:u:p:f:l:d:t:ehvxz:');

if ($opt_h) {
    help();    #printing usage/help message
    exit 0;
}

my (
    $nodelist_directory, $nodelist_file, $db_handle, $sql_statement, $domain, $type,
    $number,   $name,   $location,  $log_file,
    $sysop, $phone,  $bps, $flags,    $table_name, $db_name,
    $db_user, $db_password, $db_type
);

if ($opt_l) {
    $log_file = $opt_l;    # this needs to be the filename & path
    undef $opt_l;
}
else {
    $log_file = "nl2ftndb.log";    # default log file is in current dir
}

my $log_id = "nl2db";

logging($log_file, $log_id, "Starting... ");

# note that "opt_v" is the verbose variable
if ($opt_v) {
    logging($log_file, $log_id, "Verbose flag is set");
}

# note that "opt_x" is the debug variable
if ($opt_x) {
    logging($log_file, $log_id, "Debug flag is set");
}

#    Database type
#    This needs to be a database type for which a DBD module exists,
#    the type being the name as used in the DBD module.  The default
#    type is SQLite.
if ($opt_T) {
    $db_type = $opt_T;
    undef $opt_T;
}
else {
    $db_type = "SQLite";    # default database type is SQLite
    undef $opt_T;
}
if ($opt_v) { logging($log_file, $log_id, "Database type being used is $db_type.") };

#    Database name
if ($opt_D) {
    $db_name = $opt_D;    # this needs to be at least the filename & can also include a path
    undef $opt_D;
}
else {
    $db_name = "ftndbtst";    # default database name
}
#    Database user
if ($opt_u) {
    $db_user = $opt_u;    # Set database user
    undef $opt_u;
}
else {
    $db_user = "";    # default user is an empty string, as default SQLite does not need it
}
#    Database password
if ($opt_p) {
    $db_password = $opt_p;    # Set database password
    undef $opt_p;
}
else {
    $db_password = "";    # default database password is an empty string, as default SQLite does not need it
}

#  setup nodelist file variables
if ($opt_n) {

    $nodelist_directory = $opt_n;    # set nodelist directory variable

    if ($opt_f) {
        if ($opt_e) {    # if set, then -f option must be exact file name
            logging($log_file, $log_id, "Using exact file name $opt_f.");
            $nodelist_file = $opt_f;
        }
        else {    # if not set, then -f option is basename of nodelist file
            $nodelist_file = get_nodelist_filename($opt_f);
        }

    }
    else {        # if not set,
                  #  filename defaults to basename nodelist
        $nodelist_file = get_nodelist_filename("nodelist");
    }

}
else {
    print "\nThe Nodelist directory variable must be set... \n";
    help();
    exit(1);      #  exit after displaying usage if not set
}

logging($log_file, $log_id, "Nodelist directory: '$nodelist_directory'");
logging($log_file, $log_id, "Nodelist file: '$nodelist_file'");

if ($opt_x) {
    print "Nodelist file is '$nodelist_directory.$nodelist_file' ..\n";
}

#  nodelist table name
if ($opt_t) {
    if ( $opt_t =~ /\./ ) {    # period in proposed table name?
        logging($log_file, $log_id, "sqlite does not allow periods in table names.");
        $opt_t =~ tr/\./_/;    # change period to underscore
        $table_name = $opt_t;     #
        logging($log_file, $log_id, "Changed table name to $table_name.");
    }
    else {                     # no period in name
        $table_name = $opt_t;     #  just assign to variable
    }

}
else {
    $table_name = "Nodelist";     # default table name
}


my $zone_only = 0;     # Set default as zone 0, which is not used for zone numbers.
#  If the z parameter is defined
if ($opt_z) {
    $zone_only = $opt_z;    # If defined;  is the only zone to be loaded
    logging($log_file, $log_id, "Only loading Zone: $zone_only");
    undef $opt_z;
}

open( NODELIST, "$nodelist_directory/$nodelist_file" )
  or die logging($log_file, $log_id, "Cannot open $nodelist_directory/$nodelist_file");

#  set up domain variable
if ($opt_d) {
    $domain = $opt_d;
}
else {
    $domain = 'fidonet';       # domain defaults to fidonet
}
if ($opt_v) {                  # log domain name
    logging($log_file, $log_id, "Domain: '$domain'");
}
if ($opt_x) {
    logging($log_file, $log_id, "Debug mode is set");
}

#  set defaults
my $zone   = 1;
my $net    = 0;
my $node   = 0;
my $point  = 0;
my $region = 0;

# connect to database
$db_handle = FTN::Database::open_ftndb($db_type, $db_name, $db_user, $db_password);

#
if ($opt_v) {
    logging($log_file, $log_id, "Deleteing old entries for '$domain'");
}

#   remove any and all entries where domain = $domain when doing in insert to the table
FTN::Database::Nodelist::remove_ftn_domain($db_handle, $table_name, $domain);

# drop the old nodelist table index, if it exists.
logging($log_file, $log_id, "Dropping existing nodelist table index if it already exists.");
FTN::Database::Nodelist::drop_ftnnode_index($db_handle);

if ($opt_v) {
    logging($log_file, $log_id, "Loading database from nodelist $nodelist_file");
}

while (<NODELIST>) {
    if ( /^;/ || /^\cZ/ ) {

        #	print;
        next;
    }

    ( $type, $number, $name, $location, $sysop, $phone, $bps, $flags ) =
      split( ',', $_, 8 );

    # originally took care of these by deleteing them
    $name =~ tr/\'//d;    #  take care of single quotes in system name fields

    $location =~ tr/\'//d;     #  take care of single quotes in location fields

    $sysop =~ tr/\'//d;   # take care of single quotes in sysop name fields

    # if $flags is undefined (i.e., nothing after the baud rate)
    if ( !defined $flags ) {
        $flags = " ";
    } 
    else {
        $flags =~ s/\r?\n$//;	# else remove EOL (removes \r\n or \n but not \r) from $flags
    }

    if ( $type eq "Zone" ) {    # Zone line
        $zone = $number;
        $net  = $number;
        $node = 0;
    }    #
    elsif ( $type eq "Region" ) {    # Region line
        $region = $number;
        $net    = $number;
        $node   = 0;
    }
    elsif ( $type eq "Host" ) {      # Host line
        $net  = $number;
        $node = 0;
    }
    else {
        $node = $number;
    }

    # display where in the nodelist we are if debug flag is set
    if ($opt_x) {
        print "$type,";
        printf "%-16s", "$zone:$net/$node";
        print "$sysop\n";
    }

    # If zone_only is defined, then go to the next line if the zone number is not the same as zone_only 
    if ($zone_only > 0) {
	if ($zone != $zone_only) {
	    next;
	}
    }
    
    #	Build Insert Statement
    $sql_statement = "INSERT INTO $table_name ";

    $sql_statement .= "(type,zone,net,node,point,region,name,";
    $sql_statement .= "location,sysop,phone,baud,flags,domain,source) ";
    $sql_statement .= "VALUES (";

    $sql_statement .= "'$type', ";
    $sql_statement .= "'$zone', ";
    $sql_statement .= "'$net', ";
    $sql_statement .= "'$node', ";
    $sql_statement .= "'$point', ";
    $sql_statement .= "'$region', ";
    $sql_statement .= "'$name', ";
    $sql_statement .= "'$location', ";
    $sql_statement .= "'$sysop', ";
    $sql_statement .= "'$phone', ";
    $sql_statement .= "'$bps', ";
    $sql_statement .= "'$flags', ";
    $sql_statement .= "'$domain', ";
    $sql_statement .= "'$nodelist_file') ";

    #  this will be a debug option, but after start using more
    # complex parameter passing
    #    if ($opt_x) {
    #        print " $sql_statement ";
    #    }

    #	Execute the insert SQL statment
    $db_handle->do("$sql_statement ")
      or die logging($log_file, $log_id, $DBI::errstr);

}

if ($opt_v) {    #
    logging($log_file, $log_id, "Create ftnnode index");
}
# Recreate ftnnode Index
FTN::Database::Nodelist::create_ftnnode_index($db_handle, $table_name);

if ($opt_v) {    #
    logging($log_file, $log_id, "Closing database");
}

# disconnect from database
FTN::Database::close_ftndb($db_handle);

close NODELIST;

logging($log_file, $log_id, "Ending... ");

exit();

############################################
# subroutines
############################################

# Help message
############################################
sub help {
    print "\nUsage: nl2ftndb -n nodelist_directory [-t tablename] [-T db_type] [-D db_name] [-u db_user] [-p db_password] [-f nodelist_file] [-l log_file] [-d domain] [-e] [-v] [-x] [-z zonenum]...\n";
    print "    -n nodelist_directory = nodelist directory...\n";
    print "    [-t tablename] = Nodelist table name;  defaults to 'Nodelist'.\n\n";
    print "    [-T db_type] = database type;  defaults to 'SQLite'.\n\n";
    print "    [-D db_name] = database name & path;  defaults to 'ftndbtst'.\n\n";
    print "    [-u db_user] = database user;  defaults to an empty string.\n\n";
    print "    [-p db_password] = database password;  defaults to ab empty string.\n\n";
    print "    [-f nodelist_file] = nodelist filename, defaults to 'Nodelist'.\n";
    print "    [-l log_file] = log filename (defaults to nodelist.log in current dir)\n";
    print "    [-d domain] = nodelist domain;  defaults to 'fidonet'.\n\n";
    print "    [-z zonenum] = If present, then only the defined zone 'zonenum' is loaded.\n";
    print "   -e	If present, then nodelist_file is exact filename\n";
    print "   -v	Verbose Mode\n";
    print "   -x	Debug Mode\n";
}

################################################
# get nodelist filename, given path & base name
################################################
sub get_nodelist_filename {

    # Find the most recent version (by day number) when given a base name & dir
    # of the nodelist;  once this is implemented, this will be the default.
    # Note that if there is more than one file with the same base name, it will
    # use the first one found.

    my ( $i, @files );

    my ($basename) = @_;

    if ($opt_v) { logging($log_file, $log_id, "Searching for $basename files.") }

    opendir( DIR, $nodelist_directory );
    @files = sort {$b cmp $a} (grep( /$basename\.[0-9][0-9][0-9]$/i, readdir(DIR) ));
    closedir(DIR);

    if ( $#files == -1 ) {
        logging($log_file, $log_id, "Nodelist files $basename not found");
        print("\nNodelist files $basename not found.\n");
        help;
        exit();
    }
    else {
        if ($opt_v) {
            for ( $i = 0 ; $i < @files ; $i++ ) {
                logging($log_file, $log_id, "Nodelist file $i found: $files[$i]");
            }
        }
    }

    if ( $#files > 1 ) {
        logging($log_file, $log_id, "More than one '$basename' found, using first.");
    }

    return ( $files[0] );    # return filename

}

