#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Std;
use vars qw/ $opt_n $opt_T $opt_D $opt_u $opt_p $opt_f $opt_e $opt_l $opt_d $opt_h $opt_t $opt_v $opt_x $opt_z /;

use FTN::Database qw(&open_ftndb &close_ftndb);
use FTN::Database::Nodelist qw(&create_ftnnode_index &drop_ftnnode_index);
use FTN::Log qw(&logging);

=head1 NAME

nl2ftndb - Load information to a Nodelist table in an Fidonet/FTN SQL database.

=head1 VERSION

Version 0.10

=cut

our $VERSION = 0.10;

=head1 SYNOPSIS

C<nl2ftndb -n nodelist_directory [-t tablename] [-T db_type] [-D db_name] [-u db_user] [-p db_password] [-f nodelist_file] [-l log_file] [-d domain] [-e] [-v] [-x] [-z zonenum] [-h]>

=cut

getopts('n:T:D:u:p:f:l:d:t:ehvxz:');

if ($opt_h) {
    help();    #printing usage/help message
    exit 0;
}

my (
    $nodelist_directory, $nodelist_file, $db_handle, $sql_statement, $domain, $type,
    $number,   $name,   $location,  $log_file,
    $sysop, $phone,  $bps, $flags,    $table_name, $db_name,
    $db_user, $db_password, $db_type
);

=head1 OPTIONS

=over

=item -l

This would be the filename and path of a log file, with the default
being nl2ftndb.log in the current directory.

=cut

if ($opt_l) {
    $log_file = $opt_l;
    undef $opt_l;
}
else {
    $log_file = "nl2ftndb.log";
}

my $log_id = "nl2db";

logging($log_file, $log_id, "Starting... ");

=item -v

Verbose option.

=cut

if ($opt_v) {
    logging($log_file, $log_id, "Verbose flag is set");
}

=item -x

Debug option.

=cut

if ($opt_x) {
    logging($log_file, $log_id, "Debug flag is set");
}

=item -T

Database type.
This needs to be a database type for which a DBD module exists, the type
being the name as used in the DBD module.  The default type is SQLite.

=cut

if ($opt_T) {
    $db_type = $opt_T;
    undef $opt_T;
}
else {
    $db_type = "SQLite";    # default database type is SQLite
    undef $opt_T;
}
if ($opt_v) { logging($log_file, $log_id, "Database type being used is $db_type.") };

=item -D

Database name.
For an SQLite databse; this needs to be at least the filename and can
also include a path, and defaults to the file name ftndbtst.

=cut

if ($opt_D) {
    $db_name = $opt_D;
    undef $opt_D;
}
else {
    $db_name = "ftndbtst";
}

=item -u

Database user.
For an SQLite database, this defaults to an empty string as it does not need it.

=cut

if ($opt_u) {
    $db_user = $opt_u;
    undef $opt_u;
}
else {
    $db_user = "";
}

=item -p

Database password.
For an SQLite database, this defaults to an empty string as it does not need it.

=cut

if ($opt_p) {
    $db_password = $opt_p;
    undef $opt_p;
}
else {
    $db_password = "";
}

=item -n

The nodelist directory being used.
This is required, so if it is not set the program will exit displaying
a help message.

=cut

if ($opt_n) {

    $nodelist_directory = $opt_n;

=item -f

The nodelist file.
If the -e option is also set, then his is an exact file name.  If -e is
not set, then this is the basename of the nodelist files.

=cut

    if ($opt_f) {

=item -e

If set, then the -f option must be exact file name.  If not set, then
the -f option is basename of nodelist file.

=cut

        if ($opt_e) {
            logging($log_file, $log_id, "Using exact file name $opt_f.");
            $nodelist_file = $opt_f;
        }
        else {
            $nodelist_file = get_nodelist_filename($opt_f);
        }

    }
    else { 
        $nodelist_file = get_nodelist_filename("nodelist");
    }

}
else {
    print "\nThe Nodelist directory variable must be set... \n";
    help();
    exit(1);
}

logging($log_file, $log_id, "Nodelist directory: '$nodelist_directory'");
logging($log_file, $log_id, "Nodelist file: '$nodelist_file'");

if ($opt_x) {
    print "Nodelist file is '$nodelist_directory.$nodelist_file' ..\n";
}

=item -t

The nodelist table name to be used.
Note that if there is a period in the name, that period will be changed
to an underscore.

=cut

if ($opt_t) {
    if ( $opt_t =~ /\./ ) {    # period in proposed table name?
        logging($log_file, $log_id, "sqlite does not allow periods in table names.");
        $opt_t =~ tr/\./_/;    # change period to underscore
        $table_name = $opt_t;     #
        logging($log_file, $log_id, "Changed table name to $table_name.");
    }
    else {                     # no period in name
        $table_name = $opt_t;     #  just assign to variable
    }

}
else {
    $table_name = "Nodelist";     # default table name
}


my $zone_only = 0;     # Set default as zone 0, which is not used for zone numbers.
=item -z

If defined;  is the only zone to be loaded

=cut

if ($opt_z) {
    $zone_only = $opt_z;    # 
    logging($log_file, $log_id, "Only loading Zone: $zone_only");
    undef $opt_z;
}

open( NODELIST, "$nodelist_directory/$nodelist_file" )
  or die logging($log_file, $log_id, "Cannot open $nodelist_directory/$nodelist_file");

=item -d

If defined, this is the domain of the nodelist being loaded.  Defaults
to fidonet.

=back

=cut

if ($opt_d) {
    $domain = $opt_d;
}
else {
    $domain = 'fidonet'; 
}

if ($opt_v) {                  # log domain name
    logging($log_file, $log_id, "Domain: '$domain'");
}
if ($opt_x) {
    logging($log_file, $log_id, "Debug mode is set");
}

#  set defaults
my $zone   = 1;
my $net    = 0;
my $node   = 0;
my $point  = 0;
my $region = 0;

# connect to database
$db_handle = FTN::Database::open_ftndb($db_type, $db_name, $db_user, $db_password);

#
if ($opt_v) {
    logging($log_file, $log_id, "Deleteing old entries for '$domain'");
}

#   remove any and all entries where domain = $domain when doing in insert to the table
FTN::Database::Nodelist::remove_ftn_domain($db_handle, $table_name, $domain);

# drop the old nodelist table index, if it exists.
logging($log_file, $log_id, "Dropping existing nodelist table index if it already exists.");
FTN::Database::Nodelist::drop_ftnnode_index($db_handle);

if ($opt_v) {
    logging($log_file, $log_id, "Loading database from nodelist $nodelist_file");
}

while (<NODELIST>) {
    if ( /^;/ || /^\cZ/ ) {

        #	print;
        next;
    }

    ( $type, $number, $name, $location, $sysop, $phone, $bps, $flags ) =
      split( ',', $_, 8 );

    # originally took care of these by deleteing them
    $name =~ tr/\'//d;    #  take care of single quotes in system name fields

    $location =~ tr/\'//d;     #  take care of single quotes in location fields

    $sysop =~ tr/\'//d;   # take care of single quotes in sysop name fields

    # if $flags is undefined (i.e., nothing after the baud rate)
    if ( !defined $flags ) {
        $flags = " ";
    } 
    else {
        $flags =~ s/\r?\n$//;	# else remove EOL (removes \r\n or \n but not \r) from $flags
    }

    if ( $type eq "Zone" ) {    # Zone line
        $zone = $number;
        $net  = $number;
        $node = 0;
    }    #
    elsif ( $type eq "Region" ) {    # Region line
        $region = $number;
        $net    = $number;
        $node   = 0;
    }
    elsif ( $type eq "Host" ) {      # Host line
        $net  = $number;
        $node = 0;
    }
    else {
        $node = $number;
    }

    # display where in the nodelist we are if debug flag is set
    if ($opt_x) {
        print "$type,";
        printf "%-16s", "$zone:$net/$node";
        print "$sysop\n";
    }

    # If zone_only is defined, then go to the next line if the zone number is not the same as zone_only 
    if ($zone_only > 0) {
	if ($zone != $zone_only) {
	    next;
	}
    }
    
    #	Build Insert Statement
    $sql_statement = "INSERT INTO $table_name ";

    $sql_statement .= "(type,zone,net,node,point,region,name,";
    $sql_statement .= "location,sysop,phone,baud,flags,domain,source) ";
    $sql_statement .= "VALUES (";

    $sql_statement .= "'$type', ";
    $sql_statement .= "'$zone', ";
    $sql_statement .= "'$net', ";
    $sql_statement .= "'$node', ";
    $sql_statement .= "'$point', ";
    $sql_statement .= "'$region', ";
    $sql_statement .= "'$name', ";
    $sql_statement .= "'$location', ";
    $sql_statement .= "'$sysop', ";
    $sql_statement .= "'$phone', ";
    $sql_statement .= "'$bps', ";
    $sql_statement .= "'$flags', ";
    $sql_statement .= "'$domain', ";
    $sql_statement .= "'$nodelist_file') ";

    #  this will be a debug option, but after start using more
    # complex parameter passing
    #    if ($opt_x) {
    #        print " $sql_statement ";
    #    }

    #	Execute the insert SQL statment
    $db_handle->do("$sql_statement ")
      or die logging($log_file, $log_id, $DBI::errstr);

}

if ($opt_v) {    #
    logging($log_file, $log_id, "Create ftnnode index");
}
# Recreate ftnnode Index
FTN::Database::Nodelist::create_ftnnode_index($db_handle, $table_name);

if ($opt_v) {    #
    logging($log_file, $log_id, "Closing database");
}

# disconnect from database
FTN::Database::close_ftndb($db_handle);

close NODELIST;

logging($log_file, $log_id, "Ending... ");

exit();

############################################
# subroutines
############################################

# Help message
############################################
sub help {
    print "\nUsage: nl2ftndb -n nodelist_directory [-t tablename] [-T db_type] [-D db_name] [-u db_user] [-p db_password] [-f nodelist_file] [-l log_file] [-d domain] [-e] [-v] [-x] [-z zonenum] [-h]...\n";
    print "    [-n nodelist_directory] = nodelist directory...\n";
    print "    [-t tablename]          = Nodelist table name;  defaults to 'Nodelist'.\n\n";
    print "    [-T db_type]            = database type;  defaults to 'SQLite'.\n\n";
    print "    [-D db_name]            = database name & path;  defaults to 'ftndbtst'.\n\n";
    print "    [-u db_user]            = database user;  defaults to an empty string.\n\n";
    print "    [-p db_password]        = database password;  defaults to ab empty string.\n\n";
    print "    [-f nodelist_file]      = nodelist filename, defaults to 'nodelist'.\n";
    print "    [-l log_file]           = log filename (defaults to nodelist.log in current dir)\n";
    print "    [-d domain]             = nodelist domain;  defaults to 'fidonet'.\n\n";
    print "    [-z zone_number]        = If present, then only the defined zone 'zone_number' is loaded.\n";
    print "    [-e]	               = If present, then nodelist_file is exact filename\n";
    print "    [-v]	               = Verbose Mode\n";
    print "    [-x]	               = Debug Mode\n";
    print "    [-h]	               = Display this help\n";
}

################################################
# get nodelist filename, given path & base name
################################################
sub get_nodelist_filename {

    # Find the most recent version (by day number) when given a base name & dir
    # of the nodelist;  once this is implemented, this will be the default.
    # Note that if there is more than one file with the same base name, it will
    # use the first one found.

    my ( $i, @files );

    my ($basename) = @_;

    if ($opt_v) { logging($log_file, $log_id, "Searching for $basename files.") }

    opendir( DIR, $nodelist_directory );
    @files = sort {$b cmp $a} (grep( /$basename\.[0-9][0-9][0-9]$/i, readdir(DIR) ));
    closedir(DIR);

    if ( $#files == -1 ) {
        logging($log_file, $log_id, "Nodelist files $basename not found");
        print("\nNodelist files $basename not found.\n");
        help;
        exit();
    }
    else {
        if ($opt_v) {
            for ( $i = 0 ; $i < @files ; $i++ ) {
                logging($log_file, $log_id, "Nodelist file $i found: $files[$i]");
            }
        }
    }

    if ( $#files > 1 ) {
        logging($log_file, $log_id, "More than one '$basename' found, using first.");
    }

    return ( $files[0] );    # return filename

}

=head1 DESCRIPTION

Initial load of a particular Fidonet/FTN St. Louis Format Nodelist into an SQL Database
for Fidonet/FTN processing. The SQL Database engine is one for which a DBD module exists,
defaulting to SQLite.

=head1 EXAMPLES

Given that $NLDIR is the directory where the nodelist files can be found
and that $NLFILE is a base filename like NODELIST and that $DBFILE is
existing SQLite database file, the following command line can be used
to load a nodelist from set of the set of nodelist files all with the
same basename:

C<nl2ftndb -D $DBNAME -n $NLDIR -f NODELIST -d fidonet -v>

Given that $NLDIR is the directory where the nodelist files can be
found and that $DBFILE is an existing SQLite database file, the
following command line can be used to load a specified zone from a
specified nodelist:

C<nl2ftndb -D $DBFILE -n $NLDIR -f nodelist.197 -d fidonet -z 1 -e -v>

=head1 AUTHOR

Robert James Clay, C<< <jame at rocasa.us> >>

=head1 BUGS

Please report any bugs or feature requests to C<bug-ftn-database at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=FTN-Database>.  I will
be notified, and then you'll automatically be notified of progress on your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc nl2ftndb


You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=FTN-Database>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/FTN-Database>

=item * Search CPAN

L<http://search.cpan.org/dist/FTN-Database>

=back

=head1 SEE ALSO

 L<FTN::Database>, L<FTN::Database::Nodelist>, L<ftndbadm>,
 L<ftndbadm>, and L<listftndb>

=head1 COPYRIGHT & LICENSE

Copyright 2010 Robert James Clay, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

